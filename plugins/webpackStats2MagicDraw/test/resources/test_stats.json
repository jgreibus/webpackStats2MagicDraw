{
  "errors": [],
  "warnings": [],
  "version": "3.8.1",
  "hash": "30ab5cda0fc831756c44",
  "time": 1730,
  "publicPath": "",
  "assetsByChunkName": {
    "main": [
      "viewports-core-1.0.0.js",
      "viewports-core-1.0.0.css"
    ]
  },
  "assets": [
    {
      "name": "assets/loader-gears.gif",
      "size": 72921,
      "chunks": [],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "viewports-core-1.0.0.js",
      "size": 776222,
      "chunks": [
        0
      ],
      "chunkNames": [
        "main"
      ],
      "emitted": true,
      "isOverSizeLimit": true
    },
    {
      "name": "viewports-core-1.0.0.css",
      "size": 4218,
      "chunks": [
        0
      ],
      "chunkNames": [
        "main"
      ],
      "emitted": true
    }
  ],
  "filteredAssets": 0,
  "entrypoints": {
    "main": {
      "chunks": [
        0
      ],
      "assets": [
        "viewports-core-1.0.0.js",
        "viewports-core-1.0.0.css"
      ],
      "isOverSizeLimit": true
    }
  },
  "modules": [
    {
      "id": 0,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\parameters\\viewport-types.js",
      "name": "./src/js/parameters/viewport-types.js",
      "index": 7,
      "index2": 4,
      "size": 270,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\viewports\\viewports-controller.js",
      "issuerId": 37,
      "issuerName": "./src/js/viewports/viewports-controller.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\repository\\viewport-core\\src\\js\\viewports\\viewport.js",
          "module": "./src/js/viewports/viewport.js",
          "moduleName": "./src/js/viewports/viewport.js",
          "type": "harmony import",
          "userRequest": "../parameters/viewport-types",
          "loc": "1:0-59"
        },
        {
          "moduleId": 2,
          "moduleIdentifier": "C:\\repository\\viewport-core\\src\\js\\core\\viewports-core.js",
          "module": "./src/js/core/viewports-core.js",
          "moduleName": "./src/js/core/viewports-core.js",
          "type": "harmony import",
          "userRequest": "../gui/layout",
          "loc": "7:0-43"
        }
      ],
      "usedExports": [
        "VIEWPORT_TYPES"
      ],
      "providedExports": [
        "VIEWPORT_TYPES"
      ],
      "optimizationBailout": [],
      "depth": 4,
      "source": "export const VIEWPORT_TYPES = {\r\n    OTHER : 0,\r\n    IMAGE : 1,\r\n    MULTI_FRAME : 2,\r\n    VIDEO : 3,\r\n    ECG : 4,\r\n    SR : 5,\r\n    MPR : 6,\r\n    MIP : 7,\r\n    PDF : 8,\r\n    THIRD_PARTY_SOFTWARE: 9,\r\n\tIMAGE_JPEG : 10,\r\n\tVIDEO_STANDARD : 11,\r\n\tMULTI_FRAME_JPEG : 12\r\n};"
    },
    {
      "id": 1,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\parameters\\core-events.js",
      "name": "./src/js/parameters/core-events.js",
      "index": 9,
      "index2": 6,
      "size": 1444,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\viewports\\viewports-controller.js",
      "issuerId": 37,
      "issuerName": "./src/js/viewports/viewports-controller.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 3,
          "moduleIdentifier": "C:\\repository\\viewport-core\\src\\js\\data\\series.js",
          "module": "./src/js/data/series.js",
          "moduleName": "./src/js/data/series.js",
          "type": "harmony import",
          "userRequest": "../parameters/core-events",
          "loc": "3:0-53"
        }
      ],
      "usedExports": [
        "CORE_EVENTS"
      ],
      "providedExports": [
        "CORE_EVENTS"
      ],
      "optimizationBailout": [],
      "depth": 2,
      "source": "export const CORE_EVENTS = {\r\n\r\n    /**\r\n     * trigger after viewport was changed\r\n     */\r\n    CHANGED_ACTIVE_VIEWPORT : 'changed-active-viewport',\r\n\r\n    /**\r\n     * trigger after viewport show new instance\r\n     * @param viewportId - viewport id\r\n     * @param instanceUid - visible instance id\r\n     */\r\n    CHANGED_VIEWPORT_INSTANCE : 'changed-series-image',\r\n\r\n    /**\r\n     * trigger after viewport show new instance\r\n     * @param type - message type\r\n     * @param htmlText - message text\r\n     * @param viewportId - viewport id\r\n     */\r\n    SHOW_MESSAGE : 'show-message',\r\n\r\n    /**\r\n    * trigger after one measurement is done (NOT applied for all measurements)\r\n    */\r\n    DISABLE_ACTIVE_MEASUREMENT: 'disable-active-measurement',\r\n\r\n    /**\r\n     * trigger after viewport show new instance\r\n     * @param seriesUid - series uid\r\n     * @param progress - progress from 0 to 1\r\n     */\r\n    LOADING_SERIES: 'loading-series',\r\n\r\n    /**\r\n     * trigger after series loaded to cache completely\r\n     * @param seriesUid - series uid\r\n     */\r\n    SERIES_LOADED_COMPLETELY: 'series-loaded-completely',\r\n\r\n\t/**\r\n\t * trigger when cant laod full series data\r\n\t * @param seriesUid - series uid\r\n\t */\r\n\tSERIES_NOT_LOAD_COMPLETELY: 'series-not-loaded-completely',\r\n\r\n\r\n\t/**\r\n\t * trigger after instance is cached to server (using query retrieve)\r\n\t * @param instanceUid - instance uid\r\n\t */\r\n\tINSTANCE_IS_CACHED: 'instance_is_cached'\r\n\r\n};\r\n"
    },
    {
      "id": 2,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\core\\viewports-core.js",
      "name": "./src/js/core/viewports-core.js",
      "index": 5,
      "index2": 86,
      "size": 17684,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\index.js",
      "issuerId": 33,
      "issuerName": "./src/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
      ],
      "usedExports": [
        "viewportsCore"
      ],
      "providedExports": [
        "viewportsCore"
      ],
      "optimizationBailout": [],
      "depth": 1,
      "source": "/**!!\r\n * @name Measurements math\r\n * @description This module define all match functions used for different measurements.\r\n * @date 2017.01.01\r\n * @target-version 6.0\r\n * @author nerijus.marcius@softneta.com\r\n */\r\n\r\nexport default class MeasurementsMath {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /** Calculating angle between three points with minus sign\r\n     * @param {{x, y}} p0 - first point coordinates\r\n     * @param {{x, y}} p1 - second point coordinates\r\n     * @param {{x, y}} p2 - third point coordinates\r\n     * @param {Boolean} withMinus - calculate or ont with minus sign\r\n     * @return {Number} angle - angle between points\r\n     */\r\n\r\n    getAngleBetweenThreePoints(p0, p1, p2, withMinus = false) {\r\n\r\n        let a,\r\n            b,\r\n            c,\r\n            angle,\r\n            x1,\r\n            y1,\r\n            x2,\r\n            y2;\r\n\r\n        a = Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2);\r\n        b = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);\r\n        c = Math.pow(p2.x - p0.x, 2) + Math.pow(p2.y - p0.y, 2);\r\n        angle = Math.acos((a + b - c) / Math.sqrt(4 * a * b));\r\n        angle = angle * (180 / Math.PI);\r\n\r\n        x1 = p0.x - p1.x;\r\n        y1 = p0.y - p1.y;\r\n        x2 = p2.x - p1.x;\r\n        y2 = p2.y - p1.y;\r\n\r\n        if ((((x1 * y2) - (y1 * x2)) < 0) && (withMinus)) {\r\n            angle *= -1;\r\n        }\r\n        angle = isNaN(angle) ? 0 : angle;\r\n        return angle;\r\n    };\r\n\r\n    /** Calculating angle between two lines\r\n     * @param {{x1, y1, x2, y2}} line1 - line points coordinates\r\n     * @param {{x1, y1, x2, y2}} line2 - line points coordinates\r\n     * @return {Number} angle - angle between two lines\r\n     */\r\n    getAngleBetweenTwoLines(line1, line2) {\r\n        let dx1,\r\n            dy1,\r\n            dx2,\r\n            dy2,\r\n            d,\r\n            l2,\r\n            angle;\r\n\r\n        dx1 = line1.x2 - line1.x1;\r\n        dy1 = line1.y2 - line1.y1;\r\n        dx2 = line2.x2 - line2.x1;\r\n        dy2 = line2.y2 - line2.y1;\r\n\r\n        d = dx1 * dx2 + dy1 * dy2;   // dot product of the 2 vectors\r\n        l2 = (dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2); // product of the squared lengths\r\n        angle = Math.acos(d / Math.sqrt(l2));\r\n        angle = angle * (180 / Math.PI);\r\n\r\n        if (angle > 90) {\r\n            angle = 180 - angle;\r\n        }\r\n\r\n        angle = isNaN(angle) ? 0 : angle;\r\n        return angle;\r\n    }\r\n\r\n    /** Calculating angle middle position with custom radius\r\n     * @param {Number} r - radius\r\n     * @param {{x, y}} p1 - first point coordinates\r\n     * @param {{x, y}} center - center point coordinates\r\n     * @param {{x, y}} p2 - second point coordinates\r\n     * @return {{x, y}} point - middle point coordinates\r\n     */\r\n\r\n    angleMiddlePointWithRadius(r, p1, center, p2) {\r\n        let middlePoint,\r\n            angle1,\r\n            angle2,\r\n            angle3;\r\n\r\n        middlePoint = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n\r\n        angle1 = this.getAngleBetweenThreePoints(p2, center, {x: center.x + 100, y: center.y}, true);  // Angle from x=cos(0) y=sin(0) point, center and searching point\r\n        angle2 = this.getAngleBetweenThreePoints(p1, center, p2, true); //Angle beetwen center and searching points\r\n        angle3 = 0;\r\n\r\n        angle3 = angle3 - angle1 - angle2 / 2; //Angle from x=cos(0) y=sin(0) to searching angle middle line\r\n\r\n        //calculating coordinate on the circle with radius\r\n        middlePoint.x = center.x + r * Math.cos(angle3 * Math.PI / 180);\r\n        middlePoint.y = center.y + r * Math.sin(angle3 * Math.PI / 180);\r\n\r\n        return middlePoint;\r\n    }\r\n\r\n\r\n    /** Calculate distance between two points\r\n     * @param {{x, y}} v - point coordinates\r\n     * @param {{x, y}} w - point coordinates\r\n     * @param {Boolean} square - return square value\r\n     * @return {Number} dist - distance\r\n     */\r\n    getDistanceBetweenPoints(v, w, square = false) {\r\n        let dist;\r\n        dist = Math.pow((v.x - w.x), 2) + Math.pow((v.y - w.y), 2);\r\n        if (!square) {\r\n            dist = Math.sqrt(dist);\r\n        }\r\n        return dist;\r\n    }\r\n\r\n    /** Calculating distance between point and line\r\n     * @param {{start:{x,y}, end:{x,y}}} lineSegment - line data\r\n     * @param {{x,y}} point - point coordinates\r\n     * @return {Number} dist - distance between point and line\r\n     **/\r\n    getDistanceBetweenPointAndLine(lineSegment, point) {\r\n        let l2 = this.getDistanceBetweenPoints(lineSegment.start, lineSegment.end, true);\r\n        if (l2 === 0) {\r\n            return this.getDistanceBetweenPoints(point, lineSegment.start);\r\n        }\r\n        let t = ((point.x - lineSegment.start.x) * (lineSegment.end.x - lineSegment.start.x) +\r\n            (point.y - lineSegment.start.y) * (lineSegment.end.y - lineSegment.start.y)) / l2;\r\n        if (t < 0) {\r\n            return this.getDistanceBetweenPoints(point, lineSegment.start);\r\n        }\r\n        if (t > 1) {\r\n            return this.getDistanceBetweenPoints(point, lineSegment.end);\r\n        }\r\n\r\n        let pt = {\r\n            x: lineSegment.start.x + t * (lineSegment.end.x - lineSegment.start.x),\r\n            y: lineSegment.start.y + t * (lineSegment.end.y - lineSegment.start.y)\r\n        };\r\n        return this.getDistanceBetweenPoints(point, pt);\r\n    }\r\n\r\n    /** Calculate two lines intersection point\r\n     * @param {{x,y}} p11 - 1 line 1 point coordinates\r\n     * @param {{x,y}}  p12 - 1 line 2 point coordinates\r\n     * @param {{x,y}}  p21 - 2 line 1 point coordinates\r\n     * @param {{x,y}}  p22 - 2 line 2 point coordinates\r\n     * @return {{x,y} || null}  point - intersection point\r\n     */\r\n\r\n    getLinesIntersectPoint(p11, p12, p21, p22) {\r\n        let result,\r\n            ua_t,\r\n            ub_t,\r\n            u_b,\r\n            ua,\r\n            ub;\r\n\r\n        ua_t = (p22.x - p21.x) * (p11.y - p21.y) - (p22.y - p21.y) * (p11.x - p21.x);\r\n        ub_t = (p12.x - p11.x) * (p11.y - p21.y) - (p12.y - p11.y) * (p11.x - p21.x);\r\n        u_b = (p22.y - p21.y) * (p12.x - p11.x) - (p22.x - p21.x) * (p12.y - p11.y);\r\n\r\n        if (u_b != 0) {\r\n            ua = ua_t / u_b;\r\n            ub = ub_t / u_b;\r\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n                result = {\r\n                    x: p11.x + ua * (p12.x - p11.x),\r\n                    y: p11.y + ua * (p12.y - p11.y)\r\n                }\r\n            } else {\r\n                result = undefined; // \"No Intersection\";\r\n            }\r\n        } else {\r\n            if (ua_t == 0 || ub_t == 0) {\r\n                result = undefined; //\"Coincident\";\r\n            } else {\r\n                result = undefined; // \"Parallel\";\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    getLinesIntersectPointNoLimints(p1, p2, p3, p4) {\r\n        let part1 = (p1.x * p2.y) - (p1.y * p2.x);\r\n        let part2 = (p3.x * p4.y) - (p3.y * p4.x);\r\n        let part3 = ((p1.x - p2.x) * (p3.y - p4.y)) - ((p1.y - p2.y) * (p3.x - p4.x));\r\n\r\n        return {\r\n            x: ((part1 * (p3.x - p4.x)) - ((p1.x - p2.x) * part2)) / part3,\r\n            y: ((part1 * (p3.y - p4.y)) - ((p1.y - p2.y) * part2)) / part3\r\n        };\r\n    }\r\n\r\n    set90DegreeAnglePoint(line, p1, pTemp, boundingBox) {\r\n        let pp = {x:0, y:0};\r\n        if (Math.abs(pTemp.x - p1.x) > Math.abs(pTemp.y - p1.y))\r\n            pp = this.set90DegreeAnglePointY(line, p1, pTemp.x);\r\n        else\r\n            pp = this.set90DegreeAnglePointX(line, p1, pTemp.y);\r\n\r\n        if(boundingBox !== undefined){\r\n            if ((pp.y > boundingBox.height) || (pp.y < 0))\r\n                pp = this.set90DegreeAnglePointX(line, p1, pTemp.y);\r\n\r\n            if ((pp.x > boundingBox.width) || (pp.x < 0))\r\n                pp = this.set90DegreeAnglePointY(line, p1, pTemp.x);\r\n        }\r\n\r\n        return pp;\r\n    }\r\n\r\n    set90DegreeAnglePointY(line, p1,x){\r\n        let m, y;\r\n        m = (line.y2 - line.y1) / (line.x2 - line.x1);\r\n        y = (x - p1.x) / (m * -1) + p1.y;\r\n        return {x : x, y : y};\r\n    }\r\n\r\n\r\n    set90DegreeAnglePointX(line, p1, y){\r\n        let m, x;\r\n        m = (line.y2 - line.y1) / (line.x2 - line.x1);\r\n        x = p1.x - ((y - p1.y) * m);\r\n        return {x : x, y : y};\r\n    }\r\n\r\n\r\n    getThirdPointByRadius(point1, point2, distance) {\r\n        let tmpPoint =\r\n            {\r\n                x: point1.x + 1,\r\n                y: point1.y\r\n            },\r\n            angle,\r\n            cosAngle,\r\n            sinAngle;\r\n\r\n        angle = this.getAngleBetweenThreePoints(point2, point1, tmpPoint, true);\r\n        if(angle !== 0) angle = -angle;\r\n\r\n        tmpPoint = {\r\n            x:  distance,\r\n            y: 0\r\n        };\r\n\r\n        cosAngle = Math.cos((Math.PI / 180) * angle);\r\n        sinAngle = Math.sin((Math.PI / 180) * angle);\r\n\r\n        return {\r\n            x: (tmpPoint.x * cosAngle) - (tmpPoint.y * sinAngle) + point1.x,\r\n            y: (tmpPoint.x * sinAngle) + (tmpPoint.y * cosAngle) + point1.y\r\n        }\r\n\r\n    }\r\n\r\n    rotatePointAroundCenter(centerPoint, rotationPoint, angle)\r\n    {\r\n\r\n        let cosAngle = Math.cos((Math.PI / 180) * angle),\r\n            sinAngle = Math.sin((Math.PI / 180) * angle),\r\n\r\n            x = rotationPoint.x - centerPoint.x,\r\n            y = rotationPoint.y - centerPoint.y;\r\n\r\n        let newPosition = {\r\n                x: (x * cosAngle) - (y * sinAngle) + centerPoint.x,\r\n                y: (x * sinAngle) + (y * cosAngle) + centerPoint.y\r\n            };\r\n\r\n        return newPosition\r\n\r\n    }\r\n\r\n    getMiddlePointBetweanTwoPoints(point1, point2)\r\n    {\r\n        return {\r\n            x : (point1.x + point2.x)/2,\r\n            y : (point1.y + point2.y)/2,\r\n        }\r\n    }\r\n\r\n}"
    },
    {
      "id": 3,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\helpers\\uid\\uid-helper.js",
      "name": "./src/js/helpers/uid/uid-helper.js",
      "index": 13,
      "index2": 8,
      "size": 425,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\viewports\\2d\\image\\image-viewport.js",
      "issuerId": 38,
      "issuerName": "./src/js/viewports/2d/image/image-viewport.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
      ],
      "usedExports": [
        "default"
      ],
      "providedExports": [
        "default"
      ],
      "optimizationBailout": [],
      "depth": 4,
      "source": "export default class IdHelper\r\n{\r\n    constructor(){\r\n\r\n    }\r\n\r\n    generateUUID()\r\n    {\r\n        let d = new Date().getTime();\r\n        let uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            let r = (d + Math.random() * 16) % 16 | 0;\r\n            d = Math.floor(d / 16);\r\n            return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);\r\n        });\r\n        return uuid;\r\n    }\r\n}"
    },
    {
      "id": 4,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\parameters\\viewport-functions.js",
      "name": "./src/js/parameters/viewport-functions.js",
      "index": 17,
      "index2": 13,
      "size": 175,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\mouse\\mouse-controler.js",
      "issuerId": 3,
      "issuerName": "./src/js/helpers/uid/uid-helper.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "C:\\repository\\viewport-core\\src\\js\\core\\viewports-core.js",
          "module": "./src/js/core/viewports-core.js",
          "moduleName": "./src/js/core/viewports-core.js",
          "type": "harmony import",
          "userRequest": "../gui/layout",
          "loc": "7:0-43"
        }
      ],
      "usedExports": [
        "VIEWPORT_FUNCTIONS"
      ],
      "providedExports": [
        "VIEWPORT_FUNCTIONS"
      ],
      "optimizationBailout": [],
      "depth": 2,
      "source": "export const VIEWPORT_FUNCTIONS = {\r\n    NONE: 0,\r\n    WL: 1,\r\n    ZOOM: 2,\r\n    PAN: 3,\r\n    SCROLL: 4,\r\n    MEASURE: 5,\r\n    ROTATE: 6,\r\n    MAGNIFIER: 7,\r\n\tCROSSHAIR: 8\r\n};"
    },
    {
      "id": 77,
      "identifier": "C:\\repository\\viewport-core\\src\\js\\gui\\layout.js",
      "name": "./src/js/gui/layout.js",
      "index": 78,
      "index2": 76,
      "size": 42157,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\repository\\viewport-core\\src\\js\\core\\viewports-core.js",
      "issuerId": 2,
      "issuerName": "./src/js/core/viewports-core.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "C:\\repository\\viewport-core\\src\\js\\core\\viewports-core.js",
          "module": "./src/js/core/viewports-core.js",
          "moduleName": "./src/js/core/viewports-core.js",
          "type": "harmony import",
          "userRequest": "../gui/layout",
          "loc": "7:0-43"
        }
      ],
      "usedExports": [
        "default"
      ],
      "providedExports": [
        "default"
      ],
      "optimizationBailout": [],
      "depth": 2,
      "source": "import {CORE_EVENTS} from '../parameters/core-events'\r\nimport {VIEWPORT_TYPES} from '../parameters/viewport-types'\r\nimport {viewportsCore} from '../core/viewports-core'\r\n\r\nexport default class ViewportsLayout {\r\n\r\n\tconstructor(){\r\n\t\tthis.columns = 1;\r\n\t\tthis.rows = 1;\r\n\t\tthis.activeContainerId = '';\r\n\t\tthis.activeViewportId = '';\r\n\t\tthis.containerId = undefined;\r\n\t\tthis.position = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Return max available columns count\r\n\t * @return {integer}\r\n\t */\r\n\tstatic get MAX_COLUMNS() {\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/**\r\n\t * Return max available rows count\r\n\t * @return {integer}\r\n\t */\r\n\tstatic get MAX_ROWS() {\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/**\r\n\t * Return max available multi view columns count\r\n\t * @return {integer}\r\n\t */\r\n\tstatic get MAX_MULTI_VIEW_COLUMNS() {\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/**\r\n\t * Return max available multi view rows count\r\n\t * @return {integer}\r\n\t */\r\n\tstatic get MAX_MULTI_VIEW_ROWS() {\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/**\r\n\t * Return root container id\r\n\t * @return {string}\r\n\t */\r\n\tstatic get ROOT_CONTAINER_ID() {\r\n\t\treturn \"viewport-containers\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return used viewport container class\r\n\t * @return {string} - viewport container class name\r\n\t */\r\n\tstatic get VIEWPORT_CONTAINER_CLASS() {\r\n\t\treturn \"viewport-container\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return used active viewport container mark class\r\n\t * @return {string} viewport active container class name\r\n\t */\r\n\tstatic get ACTIVE_VIEWPORT_CONTAINER_CLASS() {\r\n\t\treturn \"active\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return vertical separator class\r\n\t * @return {string}\r\n\t */\r\n\tstatic get VERTICAL_SEPARATOR_CLASS() {\r\n\t\treturn \"vertical-separator\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return horizontal separator class\r\n\t * @return {string}\r\n\t */\r\n\tstatic get HORIZONTAL_SEPARATOR_CLASS() {\r\n\t\treturn \"horizontal-separator\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return movable separator indicator class\r\n\t * @return {string}\r\n\t */\r\n\tstatic get MOVING_SEPARATOR_CLASS() {\r\n\t\treturn \"move\";\r\n\t}\r\n\r\n\t/**\r\n\t * Return minimum viewport width\\height\r\n\t * @return {integer}\r\n\t */\r\n\tstatic get MIN_VIEWPORT_SIZE_IN_PIXELS() {\r\n\t\treturn 8;\r\n\t}\r\n\r\n\t/**\r\n\t * Return sub container class\r\n\t * @return {string}\r\n\t * */\r\n\tstatic get SUB_CONTAINER_CLASS() {\r\n\t\treturn `subcontainer`;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns view port container name by column and row position\r\n\t * @param {integer} column - container viewport column position\r\n\t * @param {integer} row - container viewport row position\r\n\t * @return {string} viewPort container id\r\n\t */\r\n\tgetViewportContainerId(column, row) {\r\n\t\treturn `container-${column}-${row}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns vertical separator id\r\n\t * @param {integer} column - separator goes after layout column\r\n\t * @return {string}\r\n\t */\r\n\tstatic getVerticalSeparatorId(column) {\r\n\t\treturn `vertical-separator-c${column}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns vertical separator id\r\n\t * @param {integer} column - separator goes after layout column\r\n\t * @param {integer} row - separator goes after layout row\r\n\t * @return {string}\r\n\t */\r\n\tstatic getHorizontalSeparatorId(column, row) {\r\n\t\treturn `horizontal-separator-c${column}-r${row}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Return number from percents\r\n\t * @return {float}\r\n\t */\r\n\tstatic getNumberFromPercentsValue(stringValueInPercents) {\r\n\t\treturn Number(stringValueInPercents.replace(\"%\", \"\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Return Percentages from numeric value\r\n\t * @return {string}\r\n\t */\r\n\tstatic getPercentages(numericValue) {\r\n\t\treturn `${numericValue}%`\r\n\t}\r\n\r\n\t/**\r\n\t * Return px from numeric value\r\n\t * @return {string}\r\n\t */\r\n\tstatic getPx(numericValue) {\r\n\t\treturn `${numericValue}px`\r\n\t}\r\n\r\n\t/**\r\n\t * Return sub containers id by container and sub container position\r\n\t * @param {integer} containerColumn - parent container column\r\n\t * @param {integer} containerRow - parent container row\r\n\t * @param {integer} column - container column\r\n\t * @param {integer} row - container row\r\n\t * @return {string} sub container id\r\n\t */\r\n\tstatic getSubContainersId(containerColumn, containerRow, column, row) {\r\n\t\treturn `subcontainer-${containerColumn}-${containerRow}-${column}-${row}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Return sub containers class by container position\r\n\t * @param {integer} containerColumn - parent container column\r\n\t * @param {integer} containerRow - parent container row\r\n\t * @return {string} sub container id\r\n\t */\r\n\tstatic getSubContainersClass(containerColumn, containerRow) {\r\n\t\treturn `subcontainer-${containerColumn}-${containerRow}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Return container position by it's id\r\n\t * @param {string} containerId - container id\r\n\t * @return {object} return container column and row\r\n\t */\r\n\tstatic getContainerPositionFromId(containerId) {\r\n\t\tlet values = containerId.match(/\\d/g);\r\n\t\treturn {column: values[0], row: values[1]};\r\n\t}\r\n\r\n\t/**\r\n\t * Return TRUE if container is sub container else FALSE\r\n\t * @param {boolean} elementId - container/sub container id\r\n\t */\r\n\tstatic isSubContainer(elementId) {\r\n\t\tlet element = document.getElementById(elementId);\r\n\t\treturn element && element.classList.contains(this.SUB_CONTAINER_CLASS);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets current layout columns count\r\n\t * @return {integer}\r\n\t */\r\n\tgetColumns() {\r\n\t\treturn this.columns;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current layout columns count\r\n\t * @param {integer} columns - count of columns\r\n\t */\r\n\tsetColumns(columns) {\r\n\t\tif (columns <= this.constructor.MAX_COLUMNS && columns > 0) {\r\n\t\t\tthis.columns = columns;\r\n\t\t} else {\r\n\t\t\tthrow Error(`Viewports layout columns should be between [0,${this.constructor.MAX_COLUMNS}]`)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets current layout rows count\r\n\t * @return {integer}\r\n\t */\r\n\tgetRows() {\r\n\t\treturn this.rows;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current layout rows count\r\n\t * @param {integer} rows - count of rows\r\n\t */\r\n\tsetRows(rows) {\r\n\t\tif (rows <= this.constructor.MAX_ROWS && rows > 0) {\r\n\t\t\tthis.rows = rows;\r\n\t\t} else {\r\n\t\t\tthrow Error(`Viewports layout rows should be between [0,${this.constructor.MAX_ROWS}]`)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Define active container id\r\n\t * @param {string} containerId - container id\r\n\t */\r\n\tsetActiveContainerId(containerId) {\r\n\t\tthis.activeContainerId = containerId;\r\n\t}\r\n\r\n\t/**\r\n\t * Return active container id\r\n\t * @returns {string} id - container id\r\n\t */\r\n\tgetActiveContainerId() {\r\n\t\treturn this.activeContainerId;\r\n\t}\r\n\r\n\t/**\r\n\t * Define active viewport id\r\n\t * @param {string} viewportId - viewport id\r\n\t */\r\n\tsetActiveViewportId(viewportId) {\r\n\t\tlet changed = viewportId !== this.activeViewportId;\r\n\t\tthis.activeViewportId = viewportId;\r\n        if(changed)\r\n        {\r\n            viewportsCore.triggerEvent(CORE_EVENTS.CHANGED_ACTIVE_VIEWPORT);\r\n            viewportsCore.referenceLinesController.updateRelatedViewports();\r\n        }\r\n\t}\r\n\r\n\t/**\r\n\t * Return active viewport id\r\n\t * @returns {string} id - viewport id\r\n\t */\r\n\tgetActiveViewportId() {\r\n\t\treturn this.activeViewportId;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates all layout DOM\r\n\t */\r\n\tcreate(containerId, position = {top: 0, right: 0, bottom: 0, left: 0}) {\r\n\t\tthis.containerId = containerId;\r\n        this.position = position;\r\n\r\n\t\tlet maxColumns = this.constructor.MAX_COLUMNS,\r\n\t\t\tmaxRows = this.constructor.MAX_ROWS,\r\n\t\t\trootContainerId = this.constructor.ROOT_CONTAINER_ID;\r\n\r\n\t\tlet rootContainer = document.createElement(\"div\");\r\n\t\trootContainer.setAttribute(\"id\", rootContainerId);\r\n\r\n\t\tlet viewer = document.getElementById(this.containerId);\r\n\t\tviewer.appendChild(rootContainer);\r\n\r\n\t\tthis.setRootContainerPosition(this.position.top, this.position.right, this.position.bottom, this.position.left);\r\n\r\n\t\tfor (let c = 1; c <= maxColumns; c++) {\r\n\t\t\tif (c < maxColumns) {\r\n\t\t\t\tlet verticalSeparator = this.createVerticalSeparator(c);\r\n\t\t\t\trootContainer.appendChild(verticalSeparator);\r\n\t\t\t}\r\n\t\t\tfor (let r = 1; r <= maxRows; r++) {\r\n\t\t\t\tlet viewContainer = this.createViewportContainer(c, r);\r\n\t\t\t\trootContainer.appendChild(viewContainer);\r\n\r\n\t\t\t\tif (r < maxRows) {\r\n\t\t\t\t\tlet horizontalSeparator = this.createHorizontalSeparator(c, r);\r\n\t\t\t\t\trootContainer.appendChild(horizontalSeparator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.setActiveViewportContainer(this.getViewportContainerId(1, 1));\r\n\r\n\t\t['resize'].forEach(event => window.addEventListener(event,\r\n\t\t\t() => {\r\n\t\t\t\tthis.updateSeparators();\r\n\t\t\t\tviewportsCore.controller.resizeAllViewports();\r\n\t\t\t}));\r\n\t}\r\n\r\n\t/**\r\n\t * Updates separators sizes depending on viewContainers sizes on window resize\r\n\t */\r\n\tupdateSeparators() {\r\n\t\t//update all vertical separators\r\n\t\tlet separators = document.getElementsByClassName(this.constructor.VERTICAL_SEPARATOR_CLASS);\r\n\t\tfor (let i = 0; i < separators.length; i++) {\r\n\t\t\tlet id = separators[i].id;\r\n\t\t\tthis.updateVerticalSeparatorPosition(id);\r\n\t\t}\r\n\r\n\t\t//update all horizontal separators\r\n\t\tseparators = document.getElementsByClassName(this.constructor.HORIZONTAL_SEPARATOR_CLASS);\r\n\t\tfor (let i = 0; i < separators.length; i++) {\r\n\t\t\tlet id = separators[i].id;\r\n\t\t\tthis.updateHorizontalSeparatorPosition(id);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates main container dimensions\r\n\t */\r\n\tsetRootContainerPosition(top = 0, right = 0, bottom = 0, left = 0) {\r\n\t\tlet rootContainerId = this.constructor.ROOT_CONTAINER_ID;\r\n\t\tlet rootContainer = document.getElementById(rootContainerId);\r\n\r\n\t\tif (!rootContainer) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\trootContainer.style.cssText = `top: ${top}px; bottom: ${bottom}px; left: ${left}px ; right: ${right}px ;`;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates new viewport container\r\n\t * @param {integer} column - container column number\r\n\t * @param {integer} row - container row number\r\n\t * @return {object} - new viewport container\r\n\t */\r\n\tcreateViewportContainer(column, row) {\r\n\t\tlet id = this.getViewportContainerId(column, row);\r\n\t\tlet container = document.createElement(\"div\");\r\n\r\n\t\tcontainer.setAttribute(\"id\", id);\r\n\t\tcontainer.setAttribute(\"class\", this.constructor.VIEWPORT_CONTAINER_CLASS);\r\n\r\n\t\tthis.addObjectClickEvent(container, (event) => this.markViewportAsActive(event));\r\n        this.addMouseWheelEvent(container, (event) => this.markViewportAsActive(event));\r\n\r\n\t\treturn container;\r\n\t}\r\n\r\n\t/**\r\n\t * Add double click event for object\r\n\t * @param {object} domObject - dom object to add event\r\n\t * @param {object} onDblClickEvent - function to call on double click event\r\n\t * */\r\n\taddObjectDoubleClickEvent(domObject, onDblClickEvent) {\r\n\t\tdomObject.addEventListener(\"dblclick\", (event) => onDblClickEvent(event));\r\n\r\n\t\tlet clickCont = 0; //event for touchable screens\r\n\t\tdomObject.addEventListener(\"touchstart\", (event) => {\r\n\t\t\tif (clickCont === 0) {\r\n\t\t\t\tclickCont++;\r\n\t\t\t\tclickCont = setTimeout(() => {\r\n\t\t\t\t\tclickCont = 0\r\n\t\t\t\t}, 500);\r\n\t\t\t} else {\r\n\t\t\t\tclickCont = 0;\r\n\t\t\t\tonDblClickEvent(event);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Add click event for object\r\n\t * @param {object} domObject - dom object to add event\r\n\t * @param {object} onClickEvent - function to call on click event\r\n\t * */\r\n\taddObjectClickEvent(domObject, onClickEvent) {\r\n\t\tdomObject.addEventListener(\"mousedown\", (event) => onClickEvent(event));\r\n\t\tdomObject.addEventListener(\"touchstart\", (event) => onClickEvent(event)); //event for touchable screens\r\n\t}\r\n\r\n\t/**\r\n\t * Add mouse wheel event for object\r\n\t * @param {object} domObject - dom object to add event\r\n\t * @param {object} onMouseWheel - function to call on mouse wheel event\r\n\t * */\r\n    addMouseWheelEvent(domObject, onMouseWheel) {\r\n        domObject.addEventListener(\"mousewheel\", (event) => onMouseWheel(event));\r\n        domObject.addEventListener(\"DOMMouseScroll\", (event) => onMouseWheel(event)); //event for touchable screens\r\n    }\r\n\r\n\t/**\r\n\t * Creates vertical separator object\r\n\t * @param {integer} column - separator column number\r\n\t * @return {object} new separator with described parameters\r\n\t */\r\n\tcreateVerticalSeparator(column) {\r\n\t\tlet className = this.constructor.VERTICAL_SEPARATOR_CLASS,\r\n\t\t\tid = this.constructor.getVerticalSeparatorId(column),\r\n\t\t\tseparator = this.createSeparator(className, id,\r\n\t\t\t\t(separatorObj, mouseMoveEvent) => {\r\n\t\t\t\t\tthis.transformVerticalSeparator(separatorObj, mouseMoveEvent)\r\n\t\t\t\t},\r\n\t\t\t\t(separator) => {\r\n\t\t\t\t\tthis.updateVerticalRelatedSeparators(separator)\r\n\t\t\t\t});\r\n\r\n\t\tseparator.setAttribute(\"data-column\", column);\r\n\t\treturn separator;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates horizontal separator object\r\n\t * @param {integer} column - separator column number\r\n\t * @param {integer} row - separator row number\r\n\t * @return {object} new separator with described parameters\r\n\t */\r\n\tcreateHorizontalSeparator(column, row) {\r\n\t\tlet className = this.constructor.HORIZONTAL_SEPARATOR_CLASS,\r\n\t\t\tid = this.constructor.getHorizontalSeparatorId(column, row),\r\n\t\t\tseparator = this.createSeparator(className, id,\r\n\t\t\t\t(separatorObj, mouseMoveEvent) => {\r\n\t\t\t\t\tthis.transformHorizontalSeparator(separatorObj, mouseMoveEvent)\r\n\t\t\t\t},\r\n\t\t\t\t(separator) => {\r\n\t\t\t\t\tthis.updateHorizontalRelatedSeparators(separator)\r\n\t\t\t\t});\r\n\r\n\t\tseparator.setAttribute(\"data-row\", row);\r\n\t\tseparator.setAttribute(\"data-column\", column);\r\n\t\treturn separator;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates general separator object\r\n\t * @param {string} className - new object class attribute value\r\n\t * @param {string} id - new object id value\r\n\t * @param {function} transformation - function which updates separator position\r\n\t * @param {function} relatedSeparatorsUpdate - function which updates related separators\r\n\t * @return {object} new separator with described parameters\r\n\t */\r\n\tcreateSeparator(className, id, transformation, relatedSeparatorsUpdate) {\r\n\t\tlet separator = document.createElement(\"div\");\r\n\r\n\t\tseparator.setAttribute(\"id\", id);\r\n\t\tseparator.setAttribute(\"class\", className);\r\n\r\n\t\tlet dragEventHandler = (event, onMove, onEnd, onLeave) => {\r\n\t\t\tevent.stopPropagation();\r\n\t\t\tevent.preventDefault();\r\n\r\n\t\t\tlet separatorStart = event.target.getBoundingClientRect();\r\n\t\t\tevent.target.classList.add(this.constructor.MOVING_SEPARATOR_CLASS);\r\n\r\n\t\t\tlet moveEvent = (e) => {\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (transformation) {\r\n\t\t\t\t\ttransformation(event.target, e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet endEvent = (e) => {\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (relatedSeparatorsUpdate) {\r\n\t\t\t\t\trelatedSeparatorsUpdate(event.target);\r\n\t\t\t\t}\r\n\t\t\t\tthis.updateViewportContainersSizes(separatorStart, event.target);\r\n\t\t\t\tevent.target.classList.remove(this.constructor.MOVING_SEPARATOR_CLASS);\r\n\t\t\t\tevent.target.parentNode.removeEventListener(onMove, moveEvent);\r\n\t\t\t\tevent.target.parentNode.removeEventListener(onEnd, endEvent);\r\n\t\t\t\tevent.target.parentNode.removeEventListener(onLeave, endEvent);\r\n\t\t\t};\r\n\r\n\t\t\tevent.target.parentNode.addEventListener(onMove, moveEvent);\r\n\t\t\tevent.target.parentNode.addEventListener(onEnd, endEvent);\r\n\t\t\tif (onLeave !== undefined) {\r\n\t\t\t\tevent.target.parentNode.addEventListener(onLeave, endEvent);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tseparator.addEventListener(\"mousedown\", (event) => {\r\n\t\t\tdragEventHandler(event, \"mousemove\", \"mouseup\", \"mouseleave\")\r\n\t\t});\r\n\t\tseparator.addEventListener(\"touchstart\", (event) => {\r\n\t\t\tdragEventHandler(event, \"touchmove\", \"touchend\", \"touchcancel\")\r\n\t\t});\r\n\r\n\t\treturn separator;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates related horizontal separator. All horizontal separators in same column are related.\r\n\t * @param {object} movedSeparatorObj - separator which was moved\r\n\t */\r\n\tupdateHorizontalRelatedSeparators(movedSeparatorObj) {\r\n\t\tlet rootContainerId = this.constructor.ROOT_CONTAINER_ID,\r\n\t\t\trootContainer = document.getElementById(rootContainerId),\r\n\t\t\tmovedSeparatorTop = movedSeparatorObj.getBoundingClientRect().top,\r\n\t\t\ttop = rootContainer.offsetTop,\r\n\t\t\tleft = rootContainer.offsetLeft,\r\n\t\t\tbottom = rootContainer.offsetTop + rootContainer.offsetHeight,\r\n\t\t\trows = this.getRows();\r\n\r\n\t\tfor (let r = 1; r < rows; r++) {\r\n\t\t\tif (r === movedSeparatorObj.dataset.row) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet separatorId = this.constructor.getHorizontalSeparatorId(movedSeparatorObj.dataset.column, r),\r\n\t\t\t\tseparator = document.getElementById(separatorId),\r\n\t\t\t\tseparatorTop = separator.getBoundingClientRect().top,\r\n\t\t\t\tnewLeft = separator.getBoundingClientRect().left - left,\r\n\t\t\t\tnewTop;\r\n\r\n\t\t\tif (r < movedSeparatorObj.dataset.row && separatorTop > movedSeparatorTop) {\r\n\t\t\t\tnewTop = movedSeparatorTop - ((movedSeparatorTop - top) / 2) - top;\r\n\t\t\t} else if (r > movedSeparatorObj.dataset.row && separatorTop < movedSeparatorTop) {\r\n\t\t\t\tnewTop = movedSeparatorTop + ((bottom - movedSeparatorTop) / 2) - top;\r\n\t\t\t}\r\n\r\n\t\t\tseparator.style.transform = `translate( ${newLeft}px, ${newTop}px)`;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates related vertical separator. All vertical separators are related.\r\n\t * @param {object} movedSeparatorObj - separator which was moved\r\n\t */\r\n\tupdateVerticalRelatedSeparators(movedSeparatorObj) {\r\n\t\tlet rootContainerId = this.constructor.ROOT_CONTAINER_ID,\r\n\t\t\trootContainer = document.getElementById(rootContainerId),\r\n\t\t\tmovedSeparatorLeft = movedSeparatorObj.getBoundingClientRect().left,\r\n\t\t\tleft = rootContainer.offsetLeft,\r\n\t\t\tright = rootContainer.offsetLeft + rootContainer.offsetWidth,\r\n\t\t\tcolumns = this.getColumns();\r\n\r\n\t\tfor (let c = 1; c < columns; c++) {\r\n\t\t\tif (c === movedSeparatorObj.dataset.column) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet separatorId = this.constructor.getVerticalSeparatorId(c),\r\n\t\t\t\tseparator = document.getElementById(separatorId),\r\n\t\t\t\tseparatorLeft = separator.getBoundingClientRect().left,\r\n\t\t\t\tnewLeft;\r\n\r\n\t\t\tif (c < movedSeparatorObj.dataset.column && separatorLeft > movedSeparatorLeft) {\r\n\t\t\t\tnewLeft = movedSeparatorLeft - ((movedSeparatorLeft - left) / 2) - left;\r\n\t\t\t} else if (c > movedSeparatorObj.dataset.column && separatorLeft < movedSeparatorLeft) {\r\n\t\t\t\tnewLeft = movedSeparatorLeft + ((right - movedSeparatorLeft) / 2) - left;\r\n\t\t\t}\r\n\r\n\t\t\tseparator.style.transform = `translate(${newLeft}px)`;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Changes horizontal separator position on mouse move\r\n\t * @param {object} separatorObj - usually event target object (horizontal separator)\r\n\t * @param {object} mouseMoveEvent - mouse move event object\r\n\t */\r\n\ttransformHorizontalSeparator(separatorObj, mouseMoveEvent) {\r\n\t\tlet topMenuHeight = separatorObj.parentNode.offsetTop,\r\n\t\t\trootContainerHeight = separatorObj.parentNode.offsetHeight,\r\n\t\t\tleft = separatorObj.previousSibling.offsetLeft,\r\n\t\t\twidth = separatorObj.previousSibling.offsetWidth,\r\n\t\t\tmousePosition = this.getMousePositionFromEvent(mouseMoveEvent),\r\n\t\t\ttop = mousePosition.y - topMenuHeight,\r\n\t\t\tminContainerSize = this.constructor.MIN_VIEWPORT_SIZE_IN_PIXELS;\r\n\r\n\t\tif (top <= minContainerSize) {\r\n\t\t\ttop = minContainerSize;\r\n\t\t} else if (top >= (rootContainerHeight - minContainerSize)) {\r\n\t\t\ttop = (rootContainerHeight - minContainerSize);\r\n\t\t}\r\n\r\n\t\tseparatorObj.style.width = width + \"px\";\r\n\t\tseparatorObj.style.transform = `translate( ${left}px, ${top}px)`;\r\n\t}\r\n\r\n\t/**\r\n\t * Changes vertical separator position on mouse move\r\n\t * @param {object} separatorObj - usually event target object (vertical separator)\r\n\t * @param {object} mouseMoveEvent - mouse move event object\r\n\t */\r\n\ttransformVerticalSeparator(separatorObj, mouseMoveEvent) {\r\n\t\tlet leftMenuWidth = separatorObj.parentNode.offsetLeft,\r\n\t\t\trootContainerWidth = separatorObj.parentNode.offsetWidth,\r\n\t\t\tmousePosition = this.getMousePositionFromEvent(mouseMoveEvent),\r\n\t\t\tleft = mousePosition.x - leftMenuWidth,\r\n\t\t\tminContainerSize = this.constructor.MIN_VIEWPORT_SIZE_IN_PIXELS;\r\n\r\n\t\tif (left <= minContainerSize) {\r\n\t\t\tleft = minContainerSize;\r\n\t\t} else if (left >= (rootContainerWidth - minContainerSize)) {\r\n\t\t\tleft = rootContainerWidth - minContainerSize;\r\n\t\t}\r\n\r\n\t\tseparatorObj.style.transform = `translate(${left}px)`;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates all viewport containers sizes by active separators\r\n\t */\r\n\tupdateViewportContainersSizes() {\r\n\t\tlet row = this.getRows(),\r\n\t\t\tcolumn = this.getColumns(),\r\n\t\t\trootContainer = document.getElementById(this.constructor.ROOT_CONTAINER_ID);\r\n\r\n\t\tfor (let c = 1; c <= column; c++) {\r\n\t\t\tlet verticalSeparatorLeft;\r\n\t\t\tif (c < column) {\r\n\t\t\t\tlet verticalSeparatorId = this.constructor.getVerticalSeparatorId(c);\r\n\t\t\t\tverticalSeparatorLeft = document.getElementById(verticalSeparatorId).getBoundingClientRect().left - rootContainer.offsetLeft;\r\n\t\t\t} else {\r\n\t\t\t\tverticalSeparatorLeft = rootContainer.offsetWidth;\r\n\t\t\t}\r\n\t\t\tfor (let r = 1; r <= row; r++) {\r\n\r\n\t\t\t\t// calculates current container width\r\n\t\t\t\tlet containerId = this.getViewportContainerId(c, r),\r\n\t\t\t\t\tcontainer = document.getElementById(containerId),\r\n\t\t\t\t\tcontainerWidthInPercents = this.constructor.getNumberFromPercentsValue(container.style.width),\r\n\t\t\t\t\tnewContainerWidthInPx = verticalSeparatorLeft - container.offsetLeft,\r\n\t\t\t\t\tnewContainerWidthInPercents = ((newContainerWidthInPx * containerWidthInPercents) / container.offsetWidth);\r\n\r\n\t\t\t\tcontainer.style.width = this.constructor.getPercentages(newContainerWidthInPercents);\r\n\r\n\t\t\t\t// if container is not last in its row\r\n\t\t\t\t// calculate container height and change next row top coordinate and height\r\n\t\t\t\t// update horizontal separator by container width\r\n\t\t\t\tif (r <= row) {\r\n\t\t\t\t\tlet horizontalSeparatorId = this.constructor.getHorizontalSeparatorId(c, r),\r\n\t\t\t\t\t\thorizontalSeparator = document.getElementById(horizontalSeparatorId),\r\n\t\t\t\t\t\thorizontalSeparatorTop;\r\n\t\t\t\t\tif (r < row) {\r\n\t\t\t\t\t\thorizontalSeparatorTop = horizontalSeparator.getBoundingClientRect().top - rootContainer.offsetTop;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\thorizontalSeparatorTop = rootContainer.offsetHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet containerHeightInPercents = this.constructor.getNumberFromPercentsValue(container.style.height),\r\n\t\t\t\t\t\tnewContainerHeightInPx = horizontalSeparatorTop - container.offsetTop,\r\n\t\t\t\t\t\tnewContainerHeightInPercents = ((newContainerHeightInPx * containerHeightInPercents) / container.offsetHeight);\r\n\r\n\t\t\t\t\tcontainer.style.height = this.constructor.getPercentages(newContainerHeightInPercents);\r\n\r\n\t\t\t\t\tif (r < row) {\r\n\t\t\t\t\t\thorizontalSeparator.style.width = this.constructor.getPx(newContainerWidthInPx);\r\n\r\n\t\t\t\t\t\tlet nextRow = r + 1,\r\n\t\t\t\t\t\t\tnextContainerId = this.getViewportContainerId(c, nextRow),\r\n\t\t\t\t\t\t\tnextContainer = document.getElementById(nextContainerId),\r\n\t\t\t\t\t\t\tnextContainerHeightInPercents = this.constructor.getNumberFromPercentsValue(nextContainer.style.height),\r\n\t\t\t\t\t\t\tnextContainerTopInPercents = this.constructor.getNumberFromPercentsValue(nextContainer.style.top),\r\n\t\t\t\t\t\t\tnextContainerTopInPx = nextContainer.getBoundingClientRect().top - rootContainer.offsetTop,\r\n\t\t\t\t\t\t\tnewNextContainerTopInPercent = nextContainerTopInPercents * horizontalSeparatorTop / nextContainerTopInPx;\r\n\r\n\t\t\t\t\t\tnextContainer.style.top = this.constructor.getPercentages(newNextContainerTopInPercent);\r\n\r\n\t\t\t\t\t\tif (nextRow === row) {\r\n\t\t\t\t\t\t\tlet newNextContainerHeightInPercent = nextContainerHeightInPercents - ( newNextContainerTopInPercent - nextContainerTopInPercents);\r\n\t\t\t\t\t\t\tnextContainer.style.height = this.constructor.getPercentages(newNextContainerHeightInPercent);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if container is not last in its column\r\n\t\t\t\t// calculate next container left coordinate and width\r\n\t\t\t\t// update next horizontal separator by next container width and update separator position\r\n\t\t\t\tlet nextColumn = c + 1;\r\n\t\t\t\tif (nextColumn <= column) {\r\n\t\t\t\t\tlet nextContainerId = this.getViewportContainerId(nextColumn, r),\r\n\t\t\t\t\t\tnextContainer = document.getElementById(nextContainerId),\r\n\t\t\t\t\t\tnextContainerLeftInPercents = this.constructor.getNumberFromPercentsValue(nextContainer.style.left),\r\n\t\t\t\t\t\tnextContainerLeftInPx = nextContainer.getBoundingClientRect().left - rootContainer.offsetLeft,\r\n\t\t\t\t\t\tnewNextContainerLeftInPercents = nextContainerLeftInPercents * verticalSeparatorLeft / nextContainerLeftInPx;\r\n\r\n\t\t\t\t\tnextContainer.style.left = this.constructor.getPercentages(newNextContainerLeftInPercents);\r\n\r\n\t\t\t\t\tif (r < row) {\r\n\t\t\t\t\t\tlet nextHorizontalSeparatorId = this.constructor.getHorizontalSeparatorId(nextColumn, r),\r\n\t\t\t\t\t\t\tnextHorizontalSeparator = document.getElementById(nextHorizontalSeparatorId),\r\n\t\t\t\t\t\t\tnextHorizontalSeparatorTop = nextHorizontalSeparator.getBoundingClientRect().top - rootContainer.offsetTop;\r\n\r\n\t\t\t\t\t\tnextHorizontalSeparator.style.transform = `translate( ${nextContainer.offsetLeft}px, ${nextHorizontalSeparatorTop}px)`;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tviewportsCore.controller.resizeAllViewports();\r\n\t}\r\n\r\n\t/**\r\n\t * Marks viewport as active\r\n\t * @param {object} event - event information\r\n\t */\r\n\tmarkViewportAsActive(event) {\r\n\t\tlet id = this.getViewportContainerIdFromEvent(event);\r\n\t\tthis.setActiveViewportContainer(id);\r\n\t}\r\n\r\n\t/**\r\n\t * Add viewport to container and mark it as active\r\n\t * @param {string} containerId - container add viewport\r\n\t * @param {object} metadata - viewport metadata\r\n\t */\r\n\taddViewportToContainer(containerId, metadata) {\r\n\t\tif (!containerId) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (metadata.isSeries) {\r\n\t\t\tlet series = viewportsCore.data.getSeries(metadata.seriesUid);\r\n\t\t\tviewportsCore.loaderController.addGearsLoaderToElement(containerId);\r\n\t\t\tseries.loadInstance(0).then((result) => {\r\n                let viewport = viewportsCore.controller.getViewportByContainerId(containerId);\r\n                if(!viewport || viewport.getType() == VIEWPORT_TYPES.IMAGE && viewport.getSeries().getUid() !== metadata.seriesUid)\r\n                {\r\n                    let viewportId = viewportsCore.controller.initViewPort(containerId, result[0].getUid());\r\n                    this.setActiveViewportId(viewportId);\r\n                }\r\n\r\n\t\t\t\tseries.loadSeriesMetadataAndPixels(containerId).then(() => {\r\n\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (containerId.indexOf('sub') === -1) {\r\n\t\t\t\tthis.loadViewportOnViewportContainer(containerId, metadata.instanceUid);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet parentContainerId = document.getElementById(containerId).parentNode.id;\r\n\t\t\t\tviewportsCore.imagesMultiViewController.createRelatedViewports(parentContainerId, metadata.instanceUid)\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t viewportsCore.eventBus.trigger('DropThumbnailOnViewportContainer', {\r\n\t\t\t vpcId: containerId,\r\n\t\t\t metadata: metadata\r\n\t\t\t });\r\n\t\t\t */\r\n\t\t}\r\n\r\n\t\tthis.setActiveViewportContainer(containerId);\r\n\t}\r\n\r\n\t/**\r\n\t * Extract viewportContainer id from event\r\n\t * @param {object} event - event information\r\n\t * @return {string} viewport container id\r\n\t */\r\n\tgetViewportContainerIdFromEvent(event) {\r\n\t\tlet position = this.getMousePositionFromEvent(event),\r\n\t\t\telement = document.elementFromPoint(position.x, position.y);\r\n\t\treturn this.getViewportContainerIdFromDOMObject(element);\r\n\t}\r\n\r\n\t/**\r\n\t * Return mouse position for touchscreen or simple desktop mouse\r\n\t * @param {object} event - event from which extraction performed\r\n\t * @return {object} x and y positions in px. Example: { x: 10, y: 20 }\r\n\t * */\r\n\tgetMousePositionFromEvent(event) {\r\n\t\tlet x, y;\r\n\t\tif (event.clientX !== undefined) {\r\n\t\t\tx = event.clientX;\r\n\t\t\ty = event.clientY;\r\n\t\t} else {\r\n\t\t\t// Todo: when Jquery functionality will be removed we do not need originalEvent check\r\n\t\t\tlet eventChangedTouches = event.originalEvent ? event.originalEvent.changedTouches[0] : event.changedTouches[0];\r\n\t\t\tx = eventChangedTouches.clientX;\r\n\t\t\ty = eventChangedTouches.clientY;\r\n\t\t}\r\n\t\treturn {x: x, y: y};\r\n\t}\r\n\r\n\t/**\r\n\t * Extract viewportContainer id from dom object\r\n\t * @param {object} domObject - DOM object\r\n\t * @return {string} viewport container id\r\n\t * */\r\n\tgetViewportContainerIdFromDOMObject(domObject) {\r\n\t\tlet subContainerClassName = this.constructor.SUB_CONTAINER_CLASS,\r\n\t\t\tid = this.getClosestObjectIdWithClass(domObject, subContainerClassName);\r\n\r\n\t\tif (id) {\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\tlet containerClassName = this.constructor.VIEWPORT_CONTAINER_CLASS;\r\n\t\treturn this.getClosestObjectIdWithClass(domObject, containerClassName);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets closes object witch contains class\r\n\t * @param {object} domObject - dom object which one starts search\r\n\t * @param {string} closestClass - class which contains closest object\r\n\t * @return {string} closest object id with closestClass name\r\n\t */\r\n\tgetClosestObjectIdWithClass(domObject, closestClass) {\r\n\t\tlet obj = domObject.closest(`.${closestClass}`);\r\n\t\treturn obj ? obj.id : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Set layout rows and columns, and update layout\r\n\t * @param {integer} columns - layout columns count\r\n\t * @param {integer} rows - layout rows count\r\n\t */\r\n\tsetLayout(columns, rows) {\r\n\t\tthis.setColumns(columns);\r\n\t\tthis.setRows(rows);\r\n\t\tthis.updateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * Update layout by set columns and rows count\r\n\t */\r\n\tupdateLayout() {\r\n\t\tlet columns = this.getColumns(),\r\n\t\t\trows = this.getRows(),\r\n\t\t\tmaxColumns = this.constructor.MAX_COLUMNS,\r\n\t\t\tmaxRows = this.constructor.MAX_ROWS;\r\n\r\n\t\tfor (let c = 1; c <= maxColumns; c++) {\r\n\t\t\tfor (let r = 1; r <= maxRows; r++) {\r\n\t\t\t\tlet containerId = this.getViewportContainerId(c, r),\r\n\t\t\t\t\tcontainerLeftPosition = (c - 1) * 100 / columns,\r\n\t\t\t\t\tcontainerTopPosition = ( r - 1 ) * 100 / rows,\r\n\t\t\t\t\tcontainerWidth = 100 / columns,\r\n\t\t\t\t\tcontainerHeight = 100 / rows,\r\n\t\t\t\t\tisVisibleContainer = c <= columns && r <= rows;\r\n\r\n\t\t\t\tthis.updateViewportContainerPosition(containerId, containerLeftPosition, containerTopPosition,\r\n\t\t\t\t\tcontainerWidth, containerHeight, isVisibleContainer);\r\n\r\n\t\t\t\tif (r < maxRows) {\r\n\t\t\t\t\tlet horizontalSeparatorId = this.constructor.getHorizontalSeparatorId(c, r),\r\n\t\t\t\t\t\tisVisibleSeparator = c < columns || r < rows;\r\n\r\n\t\t\t\t\tthis.updateHorizontalSeparatorPosition(horizontalSeparatorId, isVisibleSeparator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (c < maxColumns) {\r\n\t\t\t\tlet verticalSeparatorId = this.constructor.getVerticalSeparatorId(c),\r\n\t\t\t\t\tisVisibleSeparator = c < columns;\r\n\t\t\t\tthis.updateVerticalSeparatorPosition(verticalSeparatorId, isVisibleSeparator)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Update viewport position by passed params\r\n\t * @param {string} viewportContainerId - updated viewport container id\r\n\t * @param {integer} leftInPercents - new viewport container left position\r\n\t * @param {integer} topInPercents - new viewport container top position\r\n\t * @param {integer} widthInPercents - new viewport container width position\r\n\t * @param {integer} heightInPercents - new viewport container height position\r\n\t * @param {boolean} isVisible - describes if container will be visible\r\n\t */\r\n\tupdateViewportContainerPosition(viewportContainerId, leftInPercents, topInPercents, widthInPercents, heightInPercents, isVisible) {\r\n\t\tlet viewPortContainer = document.getElementById(viewportContainerId).style;\r\n\r\n\t\tif (isVisible) {\r\n\t\t\tviewPortContainer.top = `${topInPercents}%`;\r\n\t\t\tviewPortContainer.left = `${leftInPercents}%`;\r\n\t\t\tviewPortContainer.width = `${widthInPercents}%`;\r\n\t\t\tviewPortContainer.height = `${heightInPercents}%`;\r\n\t\t\tviewPortContainer.display = \"block\";\r\n\t\t\tviewportsCore.controller.resizeViewportByContainerId(viewportContainerId);\r\n\t\t} else {\r\n\t\t\tviewPortContainer.display = \"none\";\r\n\t\t\tviewportsCore.controller.deleteViewportByContainerId(viewportContainerId);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates vertical separators position by its siblings\r\n\t * @param {string} separatorId - updated separator id\r\n\t * @param {boolean} isVisible - describes if separator will be visible, NOTE: if value is not passed separator visibility not changes\r\n\t */\r\n\tupdateVerticalSeparatorPosition(separatorId, isVisible) {\r\n\t\tlet separator = document.getElementById(separatorId),\r\n\t\t\tleft = separator.nextSibling.offsetLeft + separator.nextSibling.clientWidth;\r\n\r\n\t\tseparator.style.transform = `translate(${left}px)`;\r\n\r\n\t\tif (isVisible !== undefined) {\r\n\t\t\tseparator.style.display = isVisible ? \"block\" : \"none\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates horizontal separators position by its siblings\r\n\t * @param {string} separatorId - updated separator id\r\n\t * @param {boolean} isVisible - describes if separator will be visible, NOTE: if value is not passed separator visibility not changes\r\n\t */\r\n\tupdateHorizontalSeparatorPosition(separatorId, isVisible) {\r\n\t\tlet separator = document.getElementById(separatorId),\r\n\t\t\ttop = separator.previousSibling.offsetTop + separator.previousSibling.offsetHeight,\r\n\t\t\tleft = separator.previousSibling.offsetLeft,\r\n\t\t\twidth = separator.previousSibling.offsetWidth;\r\n\r\n\t\tseparator.style.transform = `translate(${left}px, ${top}px)`;\r\n\t\tseparator.style.width = `${width}px`;\r\n\r\n\t\tif (isVisible !== undefined) {\r\n\t\t\tseparator.style.display = isVisible ? \"block\" : \"none\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Loads viewport content by instance uid in viewport container\r\n\t * @param {string} viewportContainerId - load content in this container\r\n\t * @param {string} instanceUid - content instance uid\r\n\t */\r\n\tloadViewportOnViewportContainer(viewportContainerId, instanceUid) {\r\n        return new Promise((resolve, reject) => {\r\n            let instance = viewportsCore.data.getInstance(instanceUid);\r\n            this.setActiveContainerId(viewportContainerId);\r\n            viewportsCore.loaderController.addGearsLoaderToElement(viewportContainerId);\r\n            instance.loadMetadata().then(() => {\r\n                // if viewport container have viewport\r\n                // viewport is removed and cached data cleaned\r\n                if (instance.getViewportType() !== VIEWPORT_TYPES.IMAGE && viewportContainerId.indexOf('sub') !== -1) {\r\n                    this.setMultiView(1, 1);\r\n                    viewportContainerId = this.getActiveContainerId();\r\n                }\r\n                let viewportId = viewportsCore.controller.initViewPort(viewportContainerId, instance.getUid());\r\n                this.setActiveViewportId(viewportId);\r\n                resolve();\r\n            }).catch(e => {\r\n                reject(e)\r\n            });\r\n        }).catch(e => {\r\n        });\r\n\t}\r\n\r\n\t/**\r\n\t * Make actions to define container as selected\r\n\t * @param {string} id - container id\r\n\t */\r\n\tsetActiveViewportContainer(id) {\r\n\t\tlet containerClassName = this.constructor.VIEWPORT_CONTAINER_CLASS,\r\n\t\t\tsubcontainerClassName = this.constructor.SUB_CONTAINER_CLASS,\r\n\t\t\tactiveContainerClassMark = this.constructor.ACTIVE_VIEWPORT_CONTAINER_CLASS;\r\n\r\n\t\tlet activeContainers = document.getElementsByClassName(`${containerClassName} ${activeContainerClassMark}`);\r\n\t\tif (activeContainers.length === 0) {\r\n\t\t\tactiveContainers = document.getElementsByClassName(`${subcontainerClassName} ${activeContainerClassMark}`);\r\n\t\t}\r\n\t\tfor (let i = 0; i < activeContainers.length; i++) {\r\n\t\t\tactiveContainers[i].classList.remove(activeContainerClassMark);\r\n\t\t}\r\n\r\n\t\tlet newActiveContainer = document.getElementById(id);\r\n\t\tif (newActiveContainer) {\r\n\t\t\tnewActiveContainer.classList.add(activeContainerClassMark);\r\n\t\t}\r\n\r\n\t\tthis.setActiveContainerId(id);\r\n\r\n\t\tlet viewports = newActiveContainer.getElementsByClassName(\"vp\");\r\n\r\n\t\tif (viewports.length > 0) {\r\n\t\t\tlet firstViewportId = viewports[0].id;\r\n\t\t\tthis.setActiveViewportId(firstViewportId);\r\n\t\t} else {\r\n\t\t\tthis.setActiveViewportId();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Loads instance to first empty container\r\n\t * @param {string} instanceUid - instance uid\r\n\t */\r\n\tloadInstanceToFirstEmptyContainer(instanceUid) {\r\n\t\tlet columns = this.getColumns(),\r\n\t\t\trows = this.getRows();\r\n\r\n\t\tfor(let r = 1; r <= rows; r++){\r\n\t\t\tfor(let c = 1; c <= columns; c++){\r\n\t\t\t\tlet containerId = this.getViewportContainerId(c, r),\r\n\t\t\t\t\tcontainer = document.getElementById(containerId);\r\n\t\t\t\tif(!container.hasChildNodes() && container.style.display === \"block\"){\r\n\t\t\t\t\tthis.loadViewportOnViewportContainer(container.id, instanceUid);\r\n\t\t\t\t\tthis.setActiveViewportContainer(container.id);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetLayoutData(){\r\n\r\n\t\tlet data = {\r\n\t\t\tcolumns: this.getColumns(),\r\n\t\t\tmaxColumns: this.constructor.MAX_COLUMNS,\r\n\t\t\trows: this.getRows(),\r\n\t\t\tmaxRows: this.constructor.MAX_ROWS,\r\n\t\t\tcontainers: []\r\n\t\t};\r\n\r\n\t\tfor (let r = 1; r <= this.constructor.MAX_ROWS; r++) {\r\n\t\t\tfor (let c = 1; c <= this.constructor.MAX_COLUMNS; c++) {\r\n\t\t\t\tlet containerId = this.getViewportContainerId(c, r),\r\n\t\t\t\t\tcontainer = document.getElementById(containerId),\r\n\t\t\t\t\tisEmpty = !container.hasChildNodes(),\r\n\t\t\t\t\tinstance = undefined;\r\n\r\n\t\t\t\tif (!isEmpty) {\r\n\t\t\t\t\tlet viewport = viewportsCore.controller.getViewportByContainerId(containerId);\r\n\t\t\t\t\tif(!!viewport)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tinstance = viewport.getInstance();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.containers.push({\r\n\t\t\t\t\tid: containerId,\r\n\t\t\t\t\tinstance: instance,\r\n\t\t\t\t\tisEmpty: isEmpty,\r\n\t\t\t\t\tcolumn: c,\r\n\t\t\t\t\trow: r,\r\n\t\t\t\t\tactive : containerId == this.getActiveContainerId()\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/**\r\n\t * Loads instance to active container\r\n\t * @param {string} instanceUid - instance uid\r\n\t */\r\n\tloadInstanceToActiveContainer(instanceUid) {\r\n\t\tlet activeContainerId = this.getActiveContainerId();\r\n\t\tthis.loadViewportOnViewportContainer(activeContainerId, instanceUid);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets multi view to container\r\n\t * @param {integer} columns - multi view columns count\r\n\t * @param {integer} rows - multi view rows count\r\n\t * */\r\n\tsetMultiView(columns, rows) {\r\n\t\tlet maxColumns = this.constructor.MAX_MULTI_VIEW_COLUMNS,\r\n\t\t\tmaxRows = this.constructor.MAX_MULTI_VIEW_ROWS;\r\n\r\n\t\tif ((columns > maxColumns && columns > 0) || (rows > maxRows && rows > 0)) {\r\n\t\t\tthrow new Error(`Multi view columns should be between [1,${columns}] or rows should be between [1,${rows}]. Now it is columns=${columns}, rows=${rows}`);\r\n\t\t}\r\n\r\n\t\tthis.updateSubContainers(columns, rows);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates multi view columns\r\n\t * @param {integer} columns - multi view columns count\r\n\t * @param {integer} rows - multi view rows count\r\n\t */\r\n\tupdateSubContainers(columns, rows) {\r\n\t\tlet activeInstanceMetadata = this.getActiveInstanceMetadata(),\r\n\t\t\tactiveContainerId = this.getActiveContainerId(),\r\n\t\t\thaveSubContainers = this.constructor.isSubContainer(activeContainerId),\r\n\t\t\tcontainer = document.getElementById(activeContainerId),\r\n\t\t\tcontainerPosition = this.constructor.getContainerPositionFromId(activeContainerId);\r\n\r\n\t\tif (activeInstanceMetadata && !activeInstanceMetadata.isImage) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (haveSubContainers) {\r\n\t\t\tactiveContainerId = this.getClosestObjectIdWithClass(container, this.constructor.VIEWPORT_CONTAINER_CLASS);\r\n\t\t\tcontainer = document.getElementById(activeContainerId);\r\n\t\t\tcontainerPosition = this.constructor.getContainerPositionFromId(activeContainerId);\r\n\r\n\t\t\tif (columns === 1 && rows === 1) {\r\n\t\t\t\twhile (container.hasChildNodes()) {\r\n\t\t\t\t\tviewportsCore.controller.deleteViewportByContainerId(container.lastChild.id);\r\n\t\t\t\t\tcontainer.removeChild(container.lastChild);\r\n\t\t\t\t}\r\n\t\t\t\tif (activeInstanceMetadata) {\r\n\t\t\t\t\tthis.addViewportToContainer(activeContainerId, activeInstanceMetadata);\r\n\t\t\t\t}\r\n\t\t\t\tthis.setActiveViewportContainer(activeContainerId);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (columns === 1 && rows === 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (activeInstanceMetadata) {\r\n\t\t\t\tviewportsCore.controller.deleteViewportByContainerId(activeContainerId);\r\n\r\n\t\t\t}\r\n\t\t\tthis.addSubContainers(activeContainerId, columns, rows);\r\n\t\t\tlet firstSubContainerId = this.constructor.getSubContainersId(containerPosition.column, containerPosition.row, 1, 1);\r\n\t\t\tthis.setActiveViewportContainer(firstSubContainerId);\r\n\t\t}\r\n\r\n\t\tthis.updateSubContainersSizes(containerPosition.column, containerPosition.row, columns, rows);\r\n\r\n\t\tif (activeInstanceMetadata) {\r\n\t\t\t//let firstSubContainerId = this.constructor.getSubContainersId(containerPosition.column, containerPosition.row, 1, 1);\r\n\t\t\t//this.addViewportToContainer(firstSubContainerId, activeInstanceMetadata);\r\n\t\t\tviewportsCore.imagesMultiViewController.createRelatedViewports(container.id, activeInstanceMetadata.instanceUid);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets all needed information from active instance reload image\r\n\t * @return {object} metadata of active viewport element\r\n\t */\r\n\tgetActiveInstanceMetadata() {\r\n\t\tlet activeInstance = viewportsCore.getActiveViewportInstance();\r\n\r\n\t\tif (!activeInstance) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tstudyUid: activeInstance.getStudyUid(),\r\n\t\t\tseriesUid: activeInstance.getSeriesUid(),\r\n\t\t\tinstanceUid: activeInstance.getUid(),\r\n\t\t\tsopClass: activeInstance.getTag(0x0008, 0x0016),\r\n\t\t\tisSeries: false,\r\n\t\t\tisImage: activeInstance.getViewportType() === VIEWPORT_TYPES.IMAGE\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Creates and adds sub containers to viewport\r\n\t * @param {string} containerId - container to add sub containers\r\n\t * */\r\n\taddSubContainers(containerId) {\r\n\t\tlet rootContainer = document.getElementById(containerId),\r\n\t\t\tcontainerPosition = this.constructor.getContainerPositionFromId(containerId),\r\n\t\t\tsubContainerClassName = this.constructor.SUB_CONTAINER_CLASS,\r\n\t\t\tsubContainerClassNameByContainer = this.constructor.getSubContainersClass(containerPosition.column, containerPosition.row),\r\n\t\t\tmaxRows = this.constructor.MAX_MULTI_VIEW_ROWS,\r\n\t\t\tmaxColumns = this.constructor.MAX_MULTI_VIEW_COLUMNS;\r\n\r\n\t\tfor (let c = 1; c <= maxColumns; c++) {\r\n\t\t\tfor (let r = 1; r <= maxRows; r++) {\r\n\t\t\t\tlet element = document.createElement(\"div\");\r\n\t\t\t\telement.id = this.constructor.getSubContainersId(containerPosition.column, containerPosition.row, c, r);\r\n\r\n\t\t\t\telement.classList.add(subContainerClassNameByContainer);\r\n\t\t\t\telement.classList.add(subContainerClassName);\r\n\r\n\t\t\t\tthis.addObjectClickEvent(element, (event) => this.markViewportAsActive(event));\r\n                this.addMouseWheelEvent(element, (event) => this.markViewportAsActive(event));\r\n\r\n\t\t\t\trootContainer.appendChild(element);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates sub containers sizes\r\n\t * @param {integer} containerColumn - parent container column\r\n\t * @param {integer} containerRow - parent container row\r\n\t * @param {integer} columns - sub containers columns count\r\n\t * @param {integer} rows - sub containers rows count\r\n\t */\r\n\tupdateSubContainersSizes(containerColumn, containerRow, columns, rows) {\r\n\t\tlet newWidth = 100 / columns,\r\n\t\t\tnewHeight = 100 / rows;\r\n\r\n\t\tfor (let c = 1; c <= this.constructor.MAX_MULTI_VIEW_COLUMNS; c++) {\r\n\t\t\tfor (let r = 1; r <= this.constructor.MAX_MULTI_VIEW_ROWS; r++) {\r\n\t\t\t\tlet elementId = this.constructor.getSubContainersId(containerColumn, containerRow, c, r),\r\n\t\t\t\t\telement = document.getElementById(`${elementId}`),\r\n\t\t\t\t\tshowElement = c <= columns && r <= rows;\r\n\r\n\t\t\t\tif (showElement) {\r\n\t\t\t\t\telement.style.display = \"block\";\r\n\t\t\t\t\telement.style.left = `${newWidth * (c - 1)}%`;\r\n\t\t\t\t\telement.style.top = `${newHeight * (r - 1)}%`;\r\n\t\t\t\t\telement.style.width = `${newWidth}%`;\r\n\t\t\t\t\telement.style.height = `${newHeight}%`;\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style.display = \"none\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}"
    }
  ]
}
